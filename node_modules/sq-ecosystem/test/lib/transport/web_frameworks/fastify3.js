/**
 * Copyright (c) 2016 - 2021 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Semver = require('semver');

if (Semver.satisfies(process.version, '<8.x')) {
    return; // dirty hack but does the job
}

const Hook = require('../../../../lib/transport/web_frameworks/fastify_versions/fastify3');
const FastHook = require('../../../../lib/transport/web_frameworks/fastify');
const getEcosystemMock = require('../../../test_utils').getEcosystemMock;
const INTERFACES = require('../../../../lib/enums').INTERFACES;

const Fastify = require('fastify');

const getApp = function (fast, eco) {

    Fastify.fastify = Fastify;
    Fastify.default = Fastify;
    Hook.reset(fast);
    const F = Hook(fast, eco);
    return F();
};

describe('Fastify 3', () => {

    it('should test the loader par', { plan: 2 }, (done) => {

        const iFace = getEcosystemMock();

        iFace[INTERFACES.INSTRUMENTATION].setWrapCallback = function (x, cb) {

            expect(x).to.equal('fastify');
            const res = cb(Fastify, { version: '2.1.9' }, 'fastify');
            expect(res).to.equal(Fastify);
            done();
        };

        FastHook.enable(iFace);
    });

    it('should test the loader par', { plan: 2 }, (done) => {

        const iFace = getEcosystemMock();

        iFace[INTERFACES.INSTRUMENTATION].setWrapCallback = function (x, cb) {

            expect(x).to.equal('fastify');
            const res = cb(Fastify, { version: '3.1.9' }, 'fastify');
            expect(res).to.not.equal(Fastify);
            done();
        };

        FastHook.enable(iFace);
    });

    it('should hook fastify and collect relevant addresses', { plan: 4 }, (done) => {

        const iFace = getEcosystemMock();
        const fastify = getApp(Fastify, iFace);
        Hook(Fastify, iFace); // should be a noop

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: (k) => k !== 'server.request.cookies'
            };
        };

        iFace[INTERFACES.TRANSPORT].propagate = function (dta, _, top) {

            expect(top).to.be.true();
            expect(dta).to.equal({
                'server.request.query': {
                    foo: 'bar'
                },
                'server.request.path_params': {
                    b: '10'
                },
                'server.request.body': {
                    hello: 'world'
                },
                'server.request.framework_endpoint': '/a/:b'
            });
        };

        fastify.post('/a/:b', () => {

            return 'ok';
        });

        fastify.inject({
            method: 'POST',
            url: '/a/10?foo=bar',
            body: { hello: 'world' }
        })
            .then((r) => {

                expect(r.statusCode).to.equal(200);
                expect(r.body).to.equal('ok');
                done();
            });
    });

    it('should hook fastify and collect relevant addresses and block an attack', { plan: 8 }, (done) => {

        const iFace = getEcosystemMock();
        const fastify = getApp(Fastify, iFace);
        Hook(Fastify, iFace); // should be a noop

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: (k) => k !== 'server.request.cookies'
            };
        };

        const SQREEN_BLOCK = 'sqreen_block';
        iFace[INTERFACES.TRANSPORT].propagate = function (dta, _, top) {

            expect(top).to.be.true();
            expect(dta).to.equal({
                'server.request.query': {
                    foo: 'bar'
                },
                'server.request.path_params': {
                    b: '10'
                },
                'server.request.body': {
                    hello: 'world'
                },
                'server.request.framework_endpoint': '/a/:b'
            });
            throw new Error(SQREEN_BLOCK);
        };

        iFace[INTERFACES.TRANSPORT].getBlockingStatus = function (err) {

            expect(err.message).to.equal(SQREEN_BLOCK);
            return {
                code: 403,
                body: 'sqreen_hijack',
                headers: { 'x-a': 'a', 'x-b': 'b' }
            };
        };

        fastify.post('/a/:b', () => {

            return 'ok';
        });

        fastify.inject({
            method: 'POST',
            url: '/a/10?foo=bar',
            body: { hello: 'world' }
        })
            .then((r) => {

                expect(r.statusCode).to.equal(403);
                expect(r.body).to.equal('sqreen_hijack');
                expect(r.headers['x-a']).to.equal('a');
                expect(r.headers['x-b']).to.equal('b');
                expect(r.headers['content-length']).to.equal(15);
                done();
            });
    });

    it('should hook fastify and collect relevant addresses and ignore the error', { plan: 2 }, (done) => {

        const iFace = getEcosystemMock();
        const fastify = getApp(Fastify, iFace);
        Hook(Fastify, iFace); // should be a noop

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => false
            };
        };

        const SQREEN_BLOCK = 'sqreen_block';

        iFace[INTERFACES.TRANSPORT].getBlockingStatus = function (err) {

            expect(err.message).to.equal(SQREEN_BLOCK);
            return null;
        };

        fastify.post('/a/:b', () => {

            throw new Error(SQREEN_BLOCK);
        });

        fastify.inject({
            method: 'POST',
            url: '/a/10?foo=bar',
            body: { hello: 'world' }
        })
            .then((r) => {

                expect(r.statusCode).to.equal(500);
                done();
            });
    });

    it('should hook fastify and collect relevant addresses and block an attack with default values', { plan: 5 }, (done) => {

        const iFace = getEcosystemMock();
        const fastify = getApp(Fastify, iFace);
        Hook(Fastify, iFace); // should be a noop

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: (k) => k !== 'server.request.cookies'
            };
        };

        const SQREEN_BLOCK = 'sqreen_block';
        iFace[INTERFACES.TRANSPORT].propagate = function (dta, _, top) {

            expect(top).to.be.true();
            expect(dta).to.equal({
                'server.request.query': {
                    foo: 'bar'
                },
                'server.request.path_params': {
                    b: '10'
                },
                'server.request.body': {
                    hello: 'world'
                },
                'server.request.framework_endpoint': '/a/:b'
            });
            throw new Error(SQREEN_BLOCK);
        };

        iFace[INTERFACES.TRANSPORT].getBlockingStatus = function (err) {

            expect(err.message).to.equal(SQREEN_BLOCK);
            return {};
        };

        fastify.post('/a/:b', () => {

            return 'ok';
        });

        fastify.inject({
            method: 'POST',
            url: '/a/10?foo=bar',
            body: { hello: 'world' }
        })
            .then((r) => {

                expect(r.statusCode).to.equal(500);
                expect(r.body).to.equal('{"statusCode":500,"error":"Internal Server Error","message":"sqreen_block"}'); // default value
                done();
            });
    });

});
