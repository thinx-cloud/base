/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const MANIFEST = require('../../manifest');
const INTERFACES = require('../enums').INTERFACES;

const HttpIncoming = require('./http.incoming');
const HttpOutgoing = require('./http.outgoing');

const HOOKS = module.exports._HOOKS = {
    producer: {
        'kafka-node': require('./kafka-node.producer'),
        amqplib: require('./amqp.producer'),
        'aws-sdk': require('./sqs.producer') // TODO: array?
    },
    consumer: {
        'aws-kcl': require('./aws-kcl.consumer'),
        amqplib: require('./amqp.consumer'),
        'aws-sdk': require('./sqs.consumer'), // TODO: array?
        'kafka-node': require('./kafka-node.consumer')
    },
    incoming: {
        http: HttpIncoming,
        https: HttpIncoming,
        graphql: require('./graphql/graphql'),
        express: require('./web_frameworks/express'),
        fastify: require('./web_frameworks/fastify'),
        koa: require('./web_frameworks/koa'),
        'koa-compose': require('./web_frameworks/koa_versions/koa_modules/koa-compose'),
        'koa-body': require('./web_frameworks/koa_versions/koa_modules/koa-body'),
        'koa-route': require('./web_frameworks/koa_versions/koa_modules/koa-route')
    },
    outgoing: {
        http: HttpOutgoing,
        https: HttpOutgoing,
        redis: require('./redis.client'),
        sqlite3: require('./sqlite.client'),
        mysql: require('./mysql.client'),
        mysql2: require('./mysql.client'),
        pg: require('./pg.client'),
        mongodb: require('./mongodb.client')
    }
};

const SEEN = new Set();

module.exports.enable = function (ecoSystemInterface) {

    const transportManifest = MANIFEST.transport;
    const hookTable = {};
    const transportTypes = Object.keys(transportManifest).filter((x) => typeof transportManifest[x] === 'object');

    transportTypes.forEach((type) => {

        const group = transportManifest[type];
        const keys = Object.keys(group).filter((k) => group[k] === true);
        keys.forEach((key) => {

            hookTable[key] = hookTable[key] || [];
            hookTable[key].push(HOOKS[type][key]);

            if (typeof HOOKS[type][key].enable === 'function') {
                HOOKS[type][key].enable(ecoSystemInterface);
            }

        });
    });

    const hookKeys = Object.keys(hookTable);
    const instrumentation = ecoSystemInterface.getInterface(INTERFACES.INSTRUMENTATION);
    hookKeys.forEach((k) => {

        instrumentation.loader.on(k, (payload) => {

            const key = payload.identity.name + '__' + payload.request;
            if (!payload.module || SEEN.has(key) === true) {
                return;
            }
            SEEN.add(key);
            // HOOKS[k](payload, ecoSystemInterface, k);
            hookTable[k]
                .forEach((hook) => {

                    hook(payload, ecoSystemInterface, k);
                });
        });
    });
};
