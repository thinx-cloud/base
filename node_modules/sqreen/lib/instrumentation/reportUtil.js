/**
 * Copyright (c) 2016 - 2021 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Hoek = require('../../vendor/hoek/lib/index');
const Config = require('../config/index');
const Fuzzer = require('../fuzzer');
const Addresses = require('../engine/addresses');

const pick = function (headers, toPick) {

    const res = {};
    for (let i = 0; i < toPick.length; ++i) {
        res[toPick[i]] = headers[toPick[i]];
    }
    return res;
};

const headersToPick = [
    'x-forwarded-for',
    'x-client-ip',
    'x-real-ip',
    'x-forwarded',
    'x-cluster-client-ip',
    'forwarded-for',
    'forwarded',
    'via',
    'user-agent',
    'content-type',
    'content-length',
    'host',
    'x-requested-with'
];

const mapRequest = module.exports.mapRequest = function (req, withPayload, topSpan) {

    req.headers = req.headers || {};
    req.connection = req.connection || {};

    const spanResolved = Addresses.resolveAllHTTPAddresses(topSpan) || {};

    // clonning prevent side effects
    const parameters = { query: Hoek.clone(spanResolved.query || req.query) };
    if (withPayload === true) {
        parameters.json = Hoek.clone(spanResolved.body || req.body);
        parameters.graphql = spanResolved.graphql || undefined;
    }

    let port = '';
    if (req.headers.host) {
        const portArr = req.headers.host.split(':');
        if (portArr.length > 1) {
            port = portArr.pop();
        }
    }

    return {
        rid: req.__sqreen_uuid,
        headers: pick(req.headers, headersToPick),
        user_agent: req.headers['user-agent'],
        scheme: 'http', // FIXME: should change based on the server type!
        verb: req.method,
        host: req.headers.host,
        port,
        remote_ip: req.connection.remoteAddress,
        remote_port: req.connection.remotePort,
        path: req.__sqreen_url || req.url, //should fix a bug when express changes the value of req.url, it makes us use a wrong value in reporting
        referer: req.headers.referer,
        parameters,
        endpoint: req.__route || Addresses.getHTTPEndpoint(topSpan)
    };
};


const MAX_ROUNDS = 10;
const SAFETY = module.exports.SAFETY = '<Redacted by Sqreen>';
const safe = function (data, i, sanitized) {

    const conf = Config.getConfig();

    if (conf === undefined || !conf.strip_sensitive_data) {
        return data;
    }

    const stripKeys = new Set(conf.strip_sensitive_keys); // optim -> set in config directly
    const stripValues = conf.strip_sentitive_regex;

    if (i === MAX_ROUNDS) {
        return data;
    }
    Object.keys(data)
        .forEach((key) => {

            if ((stripKeys.has(key.toLowerCase())) ||
                (typeof data[key] === 'string' && stripValues.find((re) => data[key].match(re)) !== undefined)) {
                if (Array.isArray(data[key]) === true) {
                    data[key]
                        .filter((x) => typeof x === 'string')
                        .forEach((x) => {

                            sanitized.push(x);
                        });
                }
                else if (typeof data[key] === 'string') {
                    sanitized.push(data[key]);
                }
                data[key] = SAFETY;
                return;
            }
            if (data[key] !== null && typeof data[key] === 'object') {
                return safe(data[key], i + 1, sanitized);
            }
        });
    return data;
};

const safeFromArray = module.exports.safeFromArray = function (data, toSanitize, n) {

    if (n === MAX_ROUNDS) {
        return data;
    }
    if (typeof data !== 'object' || data === null) {
        return data;
    }
    const keyList = Object.keys(data);
    for (let i = 0; i < keyList.length; ++i) {
        const key = keyList[i];
        if (typeof data[key] !== 'string') {
            safeFromArray(data[key], toSanitize, n + 1);
            continue;
        }
        const val = data[key]; // always a string at this point
        for (let j = 0; j < toSanitize.length; ++j) { // might be more efficient to regex this someday
            if (val.indexOf(toSanitize[j]) > -1) {
                data[key] = SAFETY;
            }
        }
    }
    return data;
};

module.exports.mapRequestAndArrayHeaders = function (req, withPayload, sanitized, topSpan) {

    const res = safe(mapRequest(req, withPayload, topSpan), 0, sanitized);
    if (withPayload === true) {
        // new sanitization on parameters
        res.parameters = safeFromArray(res.parameters, sanitized, 0);
    }
    const heads = [];
    const keys = Object.keys(res.headers);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (res.headers[key] !== undefined && res.headers[key] !== null) {
            heads.push([key, res.headers[key]]);
        }
    }
    res.headers = heads;
    // $lab:coverage:off$
    res.isRevealReplayed = Fuzzer.hasFuzzer() && Fuzzer.isRequestReplayed(req);
    // $lab:coverage:on$
    return res;
};

const RuleUtils = require('../rules/rules-callback/utils');
module.exports.mapRequestParams = function (req) {

    const claims = RuleUtils.getLookableClaims(req); // TODO: move over RE - this is legacy, maybe not
    if (claims.__sqreen_lookup && claims.__sqreen_lookup.hapi) {
        return {
            scheme: req.scheme,
            query: claims.__sqreen_lookup.hapi.query,
            body: claims.__sqreen_lookup.hapi.payload
        };
    }
    return {
        scheme: req.scheme,
        body: req.body,
        query: req.query,
        endpoint: req.__route
    };
};
