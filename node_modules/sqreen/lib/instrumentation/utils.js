/**
 * Copyright (c) 2016 - 2021 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const ExpressListEndpoints = require('express-list-endpoints');
const Log = require('../logger');
const SYNC_BLOCK = require('../enums/agent').SYNC_BLOCKING;
const kSQREEN_SYNC_BLOCKING = require('../enums/agent').kSQREEN_SYNC_BLOCKING;

module.exports.getListSession = function (resultList) {

    for (let i = 0; i < resultList.length; ++i) {
        if (resultList[i].originalSession) {
            return resultList[i].originalSession;
        }
    }
    return null;
};

module.exports.mergeHrtime = function (time) {

    return time[0] * 1000 + time[1] * 1e-6; // sec * 1000 + 1e-6 * microsec
};

module.exports.collectRoutingTableAndReportIt = function (app, cb) {

    if (!app) {
        return cb(new Error('no Express app found'));
    }

    try {
        return cb(null, ExpressListEndpoints(app));
    }
    catch (e) {
        return cb(e);
    }

};

const exitAllDomains = function () {

    const toEnable = [];
    while (process.domain) {
        toEnable.unshift(process.domain);
        process.domain.exit();
    }
    return toEnable;
};

const enterAllDomains = function (list) {

    for (let i = 0; i < list.length; ++i) {
        list[i].enter();
    }
};

const removeAllListeners = function (emitter, evt) {

    const listeners = emitter.listeners(evt);
    emitter.removeAllListeners(evt);
    let cleaned = false;
    return function () {

        if (cleaned === true) {
            return;
        }
        cleaned = true;
        for (let i = 0; i < listeners.length; ++i) {
            emitter.on(evt, listeners[i]);
        }
    };
};

module.exports.blockSync = function (cb) {

    // if, for some reason, the handler is not called, we never place back the hasUncaughtExceptionCaptureCallback
    // that, seems very very unlikely to happen
    const SQREEN_BLOCK_ERROR = new Error(SYNC_BLOCK);
    SQREEN_BLOCK_ERROR[kSQREEN_SYNC_BLOCKING] = true;
    let domainList = [];
    //$lab:coverage:off$
    if (process.domain) {
        //$lab:coverage:on$
        domainList = exitAllDomains();
    }

    const cleanup1 = removeAllListeners(process, 'uncaughtException');
    const cleanup2 = removeAllListeners(process, 'unhandledRejection');
    const handler = function (err) {

        // cleanup first (and re-establish other handlers)
        process.removeListener('uncaughtException', handler);
        process.removeListener('unhandledRejection', handler);
        cleanup1();
        cleanup2();
        //$lab:coverage:off$
        if (err === SQREEN_BLOCK_ERROR) {
            //$lab:coverage:on$
            Log.INFO('Sqreen synchronously blocked an attack');
            //$lab:coverage:off$
            if (domainList.length > 0) {
                //$lab:coverage:on$
                enterAllDomains(domainList);
            }
            // only block the request here, when you are sure nobody else caught the error
            cb();
        }
        // Should I rethrow in the other case?
    };

    setTimeout(() => {

        process.removeListener('uncaughtException', handler); // this is a noop
        process.removeListener('unhandledRejection', handler); // this is a noop
        cleanup1();
        cleanup2();
    });

    process.on('uncaughtException', handler);
    process.on('unhandledRejection', handler);
    throw SQREEN_BLOCK_ERROR;
};
