/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Shimmer = require('shimmer');
const SqliteClientTransport = require('../../../lib/transport/sqlite.client');
const INTERFACES = require('../../../lib/enums').INTERFACES;

describe('sqlite.client', () => {

    it('should cover sqlite', { plan: 30 }, (done) => {

        const module = {
            Database: class {

                constructor(filename) {

                    this.filename = filename;
                }


                run(sql, cb) {

                    cb(null, {});
                }
                get(sql, cb) {

                    cb(null, {});
                }
                all(sql, cb) {

                    cb(null, {});
                }
                each(sql, cb) {

                    cb(null, {});
                }
                exec(sql, cb) {

                    cb(null, {});
                }
                prepare(sql, cb) {

                    cb(null, {});
                }
            }
        };

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, moduleIdentity, holderName, pre, post, asyncPost, failing) {

            expect(holder[key]).to.exist();
            expect(pre).to.exist();
            expect(asyncPost).to.exist();
            expect(post).to.not.exist();
            expect(failing).to.not.exist();

            Shimmer.wrap(holder, key, (original) => {

                return function () {

                    pre.method(arguments, null, null, this);
                    const lastId = arguments.length - 1;
                    const ar = arguments;
                    const o = ar[lastId];
                    arguments[lastId] = function () {

                        asyncPost.method(ar, arguments);
                        o.apply(this, arguments);
                    };
                    return original.apply(null, arguments);
                };
            });
        };

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

            return {
                fields: ['host'],
                trigger: {}
            };
        };

        iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {


            expect(resolved).to.equal({ host: 'hello' });
            expect(trigger).to.equal({});

            return function () {

                expect(1).to.equal(1);
            };
        };

        SqliteClientTransport({ module, identity: {}, request: 'sqlite3' }, iFace);

        const db = new module.Database('hello');
        db.run('SELECT TIME;', (err, cols) => {

            expect(err).to.not.exist();
            expect(cols).to.equal({});
            done();
        });

    });

    it('should cover sqlite', { plan: 29 }, (done) => {

        const module = {
            Database: class {

                constructor(filename) {

                    this.filename = filename;
                }


                run(sql, cb) {

                    cb(null, {});
                }
                get(sql, cb) {

                    cb(null, {});
                }
                all(sql, cb) {

                    cb(null, {});
                }
                each(sql, cb) {

                    cb(null, {});
                }
                exec(sql, cb) {

                    cb(null, {});
                }
                prepare(sql, cb) {

                    cb(null, {});
                }
            }
        };

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, moduleIdentity, holderName, pre, post, asyncPost, failing) {

            expect(holder[key]).to.exist();
            expect(pre).to.exist();
            expect(asyncPost).to.exist();
            expect(post).to.not.exist();
            expect(failing).to.not.exist();

            Shimmer.wrap(holder, key, (original) => {

                return function () {

                    pre.method(arguments, null, null, this);
                    const lastId = arguments.length - 1;
                    const ar = arguments;
                    const o = ar[lastId];
                    arguments[lastId] = function () {

                        asyncPost.method(ar, arguments);
                        o.apply(this, arguments);
                    };
                    return original.apply(null, arguments);
                };
            });
        };

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

            return {
                fields: ['transport'],
                trigger: {}
            };
        };

        iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {


            expect(resolved).to.equal({ transport: 'sqlite' });
            expect(trigger).to.equal({});
        };

        SqliteClientTransport({ module, identity: {},  request: 'sqlite3' }, iFace);

        const db = new module.Database('hello');
        db.run('SELECT TIME;', (err, cols) => {

            expect(err).to.not.exist();
            expect(cols).to.equal({});
            done();
        });

    });

    it('should cover sqlite', { plan: 27 }, (done) => {

        const module = {
            Database: class {

                constructor(filename) {

                    this.filename = filename;
                }


                run(sql, cb) {

                    cb(null, {});
                }
                get(sql, cb) {

                    cb(null, {});
                }
                all(sql, cb) {

                    cb(null, {});
                }
                each(sql, cb) {

                    cb(null, {});
                }
                exec(sql, cb) {

                    cb(null, {});
                }
                prepare(sql, cb) {

                    cb(null, {});
                }
            }
        };

        const iFace = require('../../test_utils/').getEcosystemMock();

        iFace[INTERFACES.INSTRUMENTATION].strategies.wrap = function (holder, key, moduleIdentity, holderName, pre, post, asyncPost, failing) {

            expect(holder[key]).to.exist();
            expect(pre).to.exist();
            expect(asyncPost).to.exist();
            expect(post).to.not.exist();
            expect(failing).to.not.exist();

            Shimmer.wrap(holder, key, (original) => {

                return function () {

                    pre.method(arguments, null, null, this);
                    const lastId = arguments.length - 1;
                    const ar = arguments;
                    const o = ar[lastId];
                    arguments[lastId] = function () {

                        asyncPost.method(ar, arguments);
                        o.apply(this, arguments);
                    };
                    return original.apply(null, arguments);
                };
            });
        };

        iFace[INTERFACES.TRANSPORT].shouldPropagate = function () {

            return {
                fields: [],
                trigger: {}
            };
        };

        SqliteClientTransport({ module, identity: {}, request: 'sqlite3' }, iFace);
        SqliteClientTransport({ module, identity: {}, request: './lib' }, iFace);

        const db = new module.Database('hello');
        db.run('SELECT TIME;', (err, cols) => {

            expect(err).to.not.exist();
            expect(cols).to.equal({});
            done();
        });

    });

});
