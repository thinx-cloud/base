"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pythonFix = void 0;
const debugLib = require("debug");
const pMap = require("p-map");
const ora = require("ora");
const load_handler_1 = require("./load-handler");
const map_entities_per_handler_type_1 = require("./map-entities-per-handler-type");
const debug = debugLib('snyk-fix:python');
async function pythonFix(entities, options) {
    const spinner = ora({ isSilent: options.quiet, stream: process.stdout });
    spinner.text = 'Looking for supported Python items';
    spinner.start();
    const handlerResult = {
        python: {
            succeeded: [],
            failed: [],
            skipped: [],
        },
    };
    const results = handlerResult.python;
    const { entitiesPerType, skipped: notSupported } = map_entities_per_handler_type_1.mapEntitiesPerHandlerType(entities);
    results.skipped.push(...notSupported);
    spinner.succeed();
    await pMap(Object.keys(entitiesPerType), async (projectType) => {
        const projectsToFix = entitiesPerType[projectType];
        spinner.text = `Processing ${projectsToFix.length} ${projectType} items.`;
        spinner.render();
        try {
            const handler = load_handler_1.loadHandler(projectType);
            const { failed, skipped, succeeded } = await handler(projectsToFix, options);
            results.failed.push(...failed);
            results.skipped.push(...skipped);
            results.succeeded.push(...succeeded);
        }
        catch (e) {
            debug(`Failed to fix ${projectsToFix.length} ${projectType} projects.\nError: ${e.message}`);
            results.failed.push(...projectsToFix.map((p) => ({ original: p, error: e })));
        }
    }, {
        concurrency: 5,
    });
    spinner.succeed();
    return handlerResult;
}
exports.pythonFix = pythonFix;
//# sourceMappingURL=index.js.map