'use strict';
const test = require('tape');

const SDK = require('../index');
const Signal = SDK.Signal;
const Batch = SDK.Batch;
const Metric = SDK.Metric;
const Point = SDK.Point;
const Trace = SDK.Trace;

const MockAdapter = require('axios-mock-adapter');
const Axios = require('axios');

const defaultReport = Signal.prototype.report;
test('Point: create a point', (t) => {
    t.plan(2);
    const date = new Date();
    const point = new Point('signalName', 'srcName', date);
    t.ok(point instanceof Signal);
    t.deepEqual(point,{
        type: 'point',
        signal_name: 'signalName',
        actor: undefined,
        location_infra: undefined,
        location: undefined,
        source: 'srcName',
        trigger: undefined,
        payload_schema: undefined,
        payload: undefined,
        context_schema: undefined,
        context: undefined,
        time: date
    });
    new Point('signalName', 'srcName'); // coverage only
    t.end();
});

test('Point: create a point and add it to a batch', (t) => {
    t.plan(1);
    const point = new Point('signalName', 'srcName');
    SDK.initBatch(10, 1000);
    const batch = Signal.prototype.BATCH;
    point.batch();
    t.ok(batch.data.indexOf(point) > -1);
    t.end();
});

test('Point: create a point and add push it to a custom report function', (t) => {
    t.plan(1);
    const point = new Point('signalName', 'srcName');
    const report = function () {

        t.equal(this, point);
        return Promise.resolve();
    };
    SDK.setReport(report);
    return point.report()
        .then(() => t.end());
});

test('Point: create a point and refuse to push it to the backend', (t) => {
    t.plan(1);
    SDK.setReport(defaultReport);
    SDK.init('', 0, 0);
    const point = new Point('signalName', 'srcName');

    point.report()
        .catch((e) => {

            t.equal(e.message, 'Cannot send data without an API key or a session key.');
            t.end();
        });
});

test('Metric: should create a metric', (t) => {
    t.plan(2);
    const date = new Date();
    const metric = new Metric('metric_name', 'metric_source', 60, date, date, { bucket: 10 });
    t.ok(metric instanceof Signal);
    t.deepEqual(metric, {
        type: 'metric',
        signal_name: 'metric_name',
        source: 'metric_source',
        payload_schema: undefined,
        actor: undefined,
        location: undefined,
        location_infra: undefined,
        trigger: undefined,
        payload: {
            capture_interval_s: 60,
            date_started: date,
            date_ended: date,
            values: { bucket: 10 }
        },
        context: undefined,
        context_schema: undefined,
        time: date
    });
    t.end();
});

test('Trace: create a new trace', (t) => {
    t.plan(3);
    const trace = new Trace();
    const point = trace.addPoint('name', 'source', {});
    const metric = trace.addMetric('mName', 'mSource', 60, new Date(), new Date(), {});
    t.ok(trace instanceof Signal);
    t.ok(point instanceof Point);
    t.ok(metric instanceof Metric);
    t.end();
});

test('Batch: create a new batch', (t) => {
    t.plan(2);
    let calls = 0;
    const _report = Batch._report;
    Batch._report = function (toReport) {

        ++calls;
        t.equal(toReport.length, 10);
        if (calls === 2) {
            Batch._report = _report;
            t.end();
        }
        return Promise.resolve();
    };

    const batch = new Batch(10, 10000);
    for (let i = 0; i < 20; ++i) {
        batch.add({});
    }
    batch.clear();
});

test('Batch: fail to report a batch and eventually drop elements', (t) => {
    t.plan(4);
    const report = Batch._report;
    SDK.initBatch(3, 10000, () => Promise.reject());
    const batch = Signal.prototype.BATCH;
    batch.addMultiple([{}, {}]);
    t.equal(batch.data.length, 2);
    return batch.report()
        .then(() => {
            t.equal(batch.data.length, 2);
            batch.data.push({});
            batch.data.push({});
            t.equal(batch.data.length, 4);
        })
        .then(() => batch.report())
        .then(() => {

            t.equal(batch.data.length, 3);
            Batch._report = report;
        });
});

test('should report a batch to the backend', (t) => {
    t.plan(1);
    const mock = new MockAdapter(Axios);
    SDK.init('token', 3, 10000);

    mock.onPost('https://ingestion.sqreen.com/batches').reply((config) => {

        t.equal(JSON.parse(config.data).length, 3);
        done();
        return [202, {}];
    });

    const batch = Signal.prototype.BATCH;
    batch.add(new Point('hello', 'world'));
    batch.add(new Point('hello', 'world'));
    batch.add(new Point('hello', 'world'));
});
