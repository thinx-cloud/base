/**
 * Copyright (c) 2016 - 2021 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const EcosystemInterface = require('../ecosystem/ecosystemInterface');
const MainUtils = require('../util');
const Whitelist = require('./whitelist');
const Actions = require('../actions');
const TracingInterface = require('./tracingInterface');
const Ecosystem = require('../../ecosystem').ecosystem;

const kSQREEN_SYNC_BLOCKING = require('../enums/agent').kSQREEN_SYNC_BLOCKING;

const Engine = require('../engine');

const RequestStore = require('./requestStore');

const NAME = 'transport';
const transportInterface = module.exports = new EcosystemInterface(NAME);


const FINISHED_TRANSACTIONS = new WeakSet();

transportInterface.utils = {
    getXFFOrRemoteAddress: MainUtils.getXFFOrRemoteAddress,
    ensureProperIP: MainUtils.ensureProperIP
};

const ACTIONS = {
    PREVENT: 'prevent',
    NONE: 'none'
};
const checkIPandPath = function (ipAddress, req, res) {

    const whiteListRange = Whitelist.ipIsWhiteListed(ipAddress);
    const whiteListPath = Whitelist.pathIsWhiteListed(req.url);
    if (whiteListRange || whiteListPath) {

        req._sqreen_ip_whitelist = true;

        const Feature = require('../command/features');
        if (Feature.read().whitelisted_metric) {

            const Metric = require('../metric'); // FIXME: what if not signal?
            Metric.addObservations([['whitelisted', whiteListRange || whiteListPath, 1]], new Date());
        }
        return ACTIONS.NONE;
    }
    // Test for actions (block and redirect)
    if (Actions.shouldLetThisGo(req, res, ipAddress) === false) {
        return ACTIONS.PREVENT;
    }
    return ACTIONS.NONE;
};
transportInterface.ipAndPath = {
    ACTIONS, checkIPandPath
};

const checkReference = function (reference) {

    if (typeof reference !== 'object' || reference === null) {
        throw new Error('Invalid reference object');
    }
};

transportInterface.getBlockingStatus = function (err) {

    const status = {};
    try {
        if (err[kSQREEN_SYNC_BLOCKING] === true) {
            const req = {
                socket: {
                    end: function () {}
                }
            };
            const res = {
                writeHead: function (code, headers) {

                    status.code = code;
                    status.headers = headers;
                },
                write: function (body) {

                    status.body = body;
                },
                end: function () {}
            };

            require('./hooks/util').dropRequest(req, res);
            return status;
        }
    }
    catch (_) {}
    return null;

};

transportInterface.sqreenBlocking = function (err, req, res) {

    try {
        if (err[kSQREEN_SYNC_BLOCKING] === true) {
            require('./hooks/util').dropRequest(req, res);
            return true;
        }
    }
    catch (_) {}
    return false;
};

transportInterface.getHttpTrace = function (reference, ip) {

    checkReference(reference);
    return require('./record').lazyGet(reference, ip);
};

const unrefHttpTrace = function (httpTrace, req) {

    const legacy = httpTrace.isLegacyRecord;
    if (legacy === true) {
        require('./../../lib_old/instrumentation/record').STORE.delete(req);
    }
    else {
        require('./record').STORE.delete(req); // paranoia
    }
};


module.exports.stopIncomingTransaction = function (reference, cb) {

    checkReference(reference);
    if (FINISHED_TRANSACTIONS.has(reference)) {
        return;
    }
    FINISHED_TRANSACTIONS.add(reference);
    const session = require('./hooks/util').getNS();
    const cleanupList = session.get('cleanup');
    if (cleanupList !== undefined) {
        for (let i = 0; i < cleanupList.length; ++i)  {
            cleanupList[i]();
        }
    }
    return cb();
};

module.exports.enableHTTP = function () { // this MUST be called by ecosystem

    require('../engine/addresses').hardSubscribeAllHTTPAddresses();
};

module.exports.stopHttpTransaction = function (req, res, record, budgetSum, budget, monitBudget) {

    const session = require('./hooks/util').getNS();
    const legacy = record.isLegacyRecord;
    try {
        if (legacy === true) { // TODO: move in a close transaction!
            record.close(req, budgetSum, budget, res, monitBudget);
        }
        else {
            record.close(req, res, budgetSum, session.get('topSpan'));
        }
        //$lab:coverage:off$
        if (process.sqreenAsyncListener !== undefined) {
            //$lab:coverage:on$
            process.sqreenAsyncListener.cleanup(req);
        }

        const store = require('./hooks/util').getNS().get('request_store');

        if (store !== undefined) {
            store.clear();
        }
    }
    catch (e) {
        require('../exception/index').report(e).catch(() => {});
        unrefHttpTrace(record, req);
    }
};

// TODO: a way to properly keep all context from a single reference
transportInterface.startIncomingTransaction = function (reference, cb) {

    checkReference(reference);

    const Features = require('../command/features');
    const budget = require('./budget').getBudget(Features.perfmon(), reference); // perf level enabled ?
    const monitBudget = require('./budget').getMonitoringBudget(Features.perfmon(), reference);
    const session = require('./hooks/util').getNS();

    session.run(() => {

        const span = Engine.createSpanFromRoot();
        session.set('budget', budget);
        session.set('monitBudget', monitBudget);
        session.set('available_data', {}); // TODO with more stuff
        session.set('topSpan', span);
        session.set('reference', reference);
        session.set('cleanup', []);
        session.set('request_store', new RequestStore());
        return cb(session, budget, monitBudget);
    });
};

transportInterface.getSession = function () {

    return require('./hooks/util').getNS();
};

const PropagateInfos = class { // one day, this might save us in debugging times

    constructor(fields, trigger) {

        this.fields = fields;
        this.trigger = trigger;
    }
};

const FIELDS = module.exports._FIELDS = [
    'client_ip',
    'host',
    'ip',
    'message_type',
    'topic',
    'tracing_identifier',
    'transport',
    'message' // to be updated: spread the redis sub payload
];

transportInterface.getLegacySqreenMiddleware = () => require('./hooks/util').sqreenMiddleWare;

transportInterface.shouldPropagate = function (scope) {

    const trigger = TracingInterface.shouldTrace(scope);
    if (trigger === null) { // nothing to collect here
        return new PropagateInfos([], null);
    }
    return new PropagateInfos(FIELDS, trigger);
};

const noop = () => {};

transportInterface.propagate = function (resolve, trigger, isTopSpan) {

    const session = require('./hooks/util').getNS(); // TODO: recheck

    if (trigger !== null) { // FIXME: there might be multiple signals! so make this an array
        const traced = Ecosystem.trace(resolve);
        if (traced) {
            require('../signals/signalInterface')
                .createPoint(traced.signal_name)
                .trigger(trigger)
                .payload(traced.payload_schema, traced.payload)
                .report();
        }
    }

    const topSpan = session.get('topSpan');
    if (!topSpan) {
        return noop; // something went weird
    }
    let response;
    const span = topSpan.createChild();
    if (isTopSpan === true) {
        session.set('topSpan', span);
        response = () => {

            span.cleanup(); // paranoid me
            session.set('topSpan', topSpan);
        };
    }
    else {
        response = () => {

            span.cleanup(); // paranoid me
        };
    }

    const keyList = Object.keys(resolve);
    for (let i = 0; i < keyList.length; ++i) {
        const k = keyList[i];
        span.setValue(k, resolve[k]);
    }
    span.dispatch(); // FIXME: we can't block here
    return response;
};
